rules:
  "paths-kebab-case":
    given: "$.paths[*]~"
    severity: warn
    then:
      function: pathsKebabCase
  "path-no-redundant-prefixes":
    description: "Не следует использовать избыточные термины в методах, не относящиеся к смыслу ресурса/команды"
    given: "$.paths[*]~"
    severity: "warn"
    then:
      function: "pattern"
      functionOptions:
        notMatch: ".*?((api)|(http)|(service)).*?"
  "query-params-camel-case":
    description: "Для query параметров запроса используем camelCase"
    given: "$.paths..parameters[?(@.in=='query')].name"
    severity: "warn"
    then:
      function: "casing"
      functionOptions:
        type: "camel"
  "body-fields-camel-case":
    description: "Для именования полей тела запроса используем camelCase"
    given: "$..requestBody..properties[*]~"
    severity: "warn"
    then:
      function: "casing"
      functionOptions:
        type: "camel"
  "method-operation-id-camel-case":
    description: "Для именования operationId используем camelCase"
    given: "$..operationId"
    severity: "warn"
    then:
      function: "casing"
      functionOptions:
        type: "camel"
  "method-request-response-components":
    description: "Тело запроса и ответа должны быть вынесены в components и ссылаться через $ref"
    # TODO не сработает, если варианты responses или само значение requestBody вынесены через $ref
    given: "$..content..schema"
    severity: "warn"
    then:
      field: "$ref"
      function: "truthy"
    resolved: false
  "object-request-response-postfix":
    description: "Объекты запросов и ответов именуются стилем PascalCase с постфиксами Request/Response"
    # TODO не сработает, если варианты responses или само значение requestBody вынесены через $ref
    given: "$..content..schema['$ref']"
    severity: "warn"
    then:
      function: "pattern"
      functionOptions:
        match: ".*?([A-Z][a-z0-9]+)+((Request)|(Response))$"
    resolved: false
  # TODO сложно реализовать
  # "object-request-response-extraction":
  "enum-discriminator-upper-snaker-case":
    description: "Перечисления и значения маппинга для дискриминатора именуются UPPER_SNAKE_CASE"
    given: "$..enum[*]"
    severity: "warn"
    then:
      function: "casing"
      functionOptions:
        type: "macro"
  # TODO сложно реализовать
  # "offset-pagination":
  # "cursor-pagination":
  # TODO такая себе проверка
  "sorting":
    description: "Для сортировки используем параметр sortBy"
    given: "$.paths..parameters[?(@.in=='query')].name"
    severity: "warn"
    then:
      function: "pattern"
      functionOptions:
        notMatch: "(^sort$)|(^sortby$)"
  # TODO сложно реализовать
  # "filtering":
  "date-time-format-iso-8601":
    description: "В описании поля с датой должно быть указано, что используется ISO 8601"
    given: "$..[?(@.format == 'date')].description"
    severity: "warn"
    then:
      function: "pattern"
      functionOptions:
        match: ".*?8601.*?"
  # TODO похоже это не возможно, смотри https://stackoverflow.com/a/34040271/22989572
#  "country-forma-iso-3166":
#    description: "В описании поля со страной должно быть указано, что используется ISO 3166"
#    given: "$..[?(@.name=~/.+Country/)].description"
#    severity: "warn"
#    then:
#     function: "pattern"
#     functionOptions:
#       match: ".*?3166.*?"
  # TODO Аналогично предыдущему
  # "currency-format-iso-4217":
  "url-versioning":
    description: "В начале пути должна быть версия(/beta, /v1, /v2, ...)"
    given: "$.paths[*]~"
    severity: "warn"
    then:
      function: "pattern"
      functionOptions:
        match: "^/((beta)|(v[0-9]+)).*?"
  # TODO что-то на непонятном
  # "use-correct-url-sequence":
  "provide-head-method":
    description: "Если ручка возвращает файл, то должна быть аналогичная ручка HEAD"
    given: "$.paths[?(!@.head)].*[?(@..['application/octet-stream'])]"
    severity: "warn"
    then:
      function: "undefined"
